 <!DOCTYPE html>
<html>

<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Object Inheritance in JavaScript</title>
<link href="../00-Commons/Main.css" rel="stylesheet" type="text/css"/>
<link href="../00-Commons/JSHTML.css"  rel="stylesheet" type="text/css" />
<script src="../00-Commons/JSHTML.js"  type="text/javascript"></script>
<script src="../00-Archive/01a-Data-Typing-1-Archive/typing.js"></script>

<script type="text/javascript">	
	window.addEventListener("load", function(){applyJSHTML();});		
</script>
	
<style type="text/css">
blockquote {border-left: thin blue solid;padding-left: 1em;font-style: italic;}
dfn {color: rgb(0,0,255);font-style: oblique;}
var {font-style: italic;color: purple;}
mark {color: red;font-weight: bold;border: thin blue solid;}
.display {background-color:rgb(255,225,200);border:thin maroon solid;padding:1em;}
</style>
</head>

<body class="GPeachBlue" style="font-size:16px;width:800px;font-family: Georgia">
<span style="position:absolute;left:900px">© 2019 Meouzer Consortium</span>
<header>
	<h1>A Review of Inheritance in JavaScript</h1>
	<span class="centerTable" style="font-size: 1.3em;margin-top:.5em;color:maroon">Meouzer</span>
	<span class="centerTable" style="font-size: 1.2em; color: maroon;">Meouzer the Snarky Cat Programming Cat</span>
	<span class="centerTable" style="font-size: 1.2em; color: maroon;">meouzer@gmail.com</span>
	</header>	
	
<blockquote class="mt2 pth" style="background-color:rgba(255,192,203,.2);border:thick rgba(90,0,0,.1) ridge;" >
	<img alt="loading" src="../00-Commons/Meouzer.jpg" style="width: 100px; display: inline-block;">
	<div style="display: inline-block; width: 500px; vertical-align: top;text-align:left; margin-left:1em; line-height: 1.5em">
		C++ hsas only one wase! It rgiht wise!! JavaScript countless waises, and all's wrung!!!.<br>
		<span style="float:right">Meouzer</span></div>
</blockquote>
<section>
	<h2>About the Author</h2>
	<p>
		As an adept JavaScript master, Meouzer thoroughly enjoys writing his own articles, and I am grateful 
		for the opportunity of employing my skills in correction of the atrocious grammar that cats think 
		they can get away with. Meouzer's spelling is natively quite good, but since cats write articles
		with keyboards, it's understandable that misspellings are the catographical results. Actually, and this is quite 
		embarrassing, Meouzer was an excellent 
		typist until we had him declawed. For some unfathomable reason the vet didn't disclose the adverse effects of declawing 
		on a cat's ability to accurately strike keys. This was just like the time Meouzer was taken in for rambunctiousness and 
		somehow ended up getting neutered. After some protest, the fee was waived, which was a great deal since we were going to 
		have him neutered anyway.
	</p>
</section>
<section>
	<h2>Glossary and Fun Facts</h2>
	<p>
		The glossary is in logical rather than alphabetical order.
	</p>
		<dl> 					
			<dt>Primitive</dt>
			<dd>
			<p>
				A JavaScript element is a <dfn>primitive</dfn> if it has permanently has no properties of its own.
				By permanent we mean that the element has no properties at definition, and properties can never 
				be added to the element after its definition.
			</p>
				<p>
					Explicitly the primitives are the, <var>undefineds</var>, <var>nulls</var>, <var>booleans</var>, <var>numbers</var>,
					<var>strings</var>, <var>symbols</var>, and <var>bigints</var>. A test for being a primitive is that
					<var>typeof(x)</var> is either <var>"undefined"</var>, <var>"null"</var>, <var>"boolean"</var>, <var>"number"</var>,
					<var>"string"</var>, <var>"symbol"</var>, or <var>"bigint"</var>.
				</p>				 
			</dd>
			
			<dt>Object</dt>
			<dd>
				An <dfn>object</dfn> is an element that is not a primitive. 
			</dd>
			
			<dt>Direct Definition of Property</dt>
			<dd>
				<p>
				For an object <var>x</var>, a property <var>p</var> may be <dfn>directly defined</dfn> through an
				assignment statement such as <var>x.p = ...</var> or through a property
				descriptor used in one of the following manners.
				</p>
				<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
					
					// First manner. Create property p at creation of x	
					var x = Object.create(y, 
					{
						p: // define property p of x
						{
							// This object is a property descriptor
						},
						
						...;
					});
					
					// Second manner. Define the property and other properties together.
					Object.DefineProperties(x, 
					{
						p: // define property p of x
						{
							// This object is a property descriptor
						},
						
						...;

					});
					
					// Third manner. Define just the property and no others 
					Object.defineProperty(x, "p", property-descriptor-here);
					
				</div>				
			</dd>
			
			<dt>Internal Prototype</dt>
			<dd>
				<p>
					The internal prototype of any element <var>x</var> is <var>Object.getPrototypeOf(x)</var>. 
					Every JavaScript element except for the <var>undefineds and </var><var>nulls</var> 
					has a internal prototype.
					For an element <var>x</var>, if <var>x.__proto__</var> is defined then it is the internal
					prototype. However the proto property is not defined for null objects.
					
				</p>				
				<p>
					The internal prototype of <var>booleans</var>, <var>numbers</var>, and <var>strings</var> is obtained 
					by boxing: such a primitive <var>x</var> really doesn't have an internal prototype but when 
					<var>Object.getPrototypeOf(x)</var>
					is called, JavaScript behind the scenes converts <var>x</var> to an object and then
					takes the internal prototype: <var>booleans</var> are converted to <var>Booleans</var>, 
					<var>numbers</var> are converted to <var>Numbers</var>, and <var>strings</var> 
					are converted to <var>Strings</var>: Only after this conversion is <var>Object.getPrototypeOf()</var>
					called. So technically, <var>booleans</var>, <var>numbers</var>, and <var>strings</var> 
					don't have internal prototypes.			
				</p>	
				<dl>
					<dt>Boxing</dt>
					<dd>
						Boxing is when JavaScript automatically replaces <var>booleans</var>, <var>numbers</var>, or <var>strings</var> 
						with <var>Booleans</var>, <var>Numbers</var>, or <var>Strings</var> before an operation on the element
						is executed. We have an example above, but usually boxing is used in connection with evaluating
						properties. For example, if <var>String.prototype</var> defines a property <var>p</var>, then 
						<var>"cat".p</var> is first evaluated by turning <var>"cat"</var> into <var>aString = new String("cat")</var>.
						Then <var>aString.p is</var> determined and gives the value of <var>"cat".p</var>. 						
					</dd>
				</dl>			
			</dd>
			
			<dt>Top Level Object </dt>
			<dd>
				<p>
				Any object <var>x</var> whose internal prototype is <var>null</var>. Equivalently
				an object that doesn't inherit from another object.
				</p>
				<p>
					<var>Object.prototype</var> is the most famous top level object. All the
					other top level objects take the form <var>Object.create(null, ...)</var>.
					These are called top level null objects. See Null object.
				</p>
			</dd>
							
			<dt>Inheritance Chain or Prototype Chain</dt>
			<dd>
				<p>
					For an element <var>x</var>, neither <var>undefined</var> nor <var>null</var>,
					its inheritance or prototype sequence/chain starts with <var>x</var>. Given
					a member of the sequence the next member is its internal prototype. The
					sequence continues until a top level object is reached, which is the last
					member of the sequence or chain. 
				</p>
				<p>
					We say that <var>x</var> inherits from the other members <var>y</var> of the inheritance chain
					of <var>x</var>, because <var>x</var> inherits their properties (see Inherited Property).										
				</p>
				<dl>
					<dt>Degree of Inheritance</dt>
					<dd>
						The degree of the inheritance of <var>x</var> from <var>y</var> is the number of times
						you have to take the internal prototype starting with <var>x</var> to reach <var>y</var>.
					</dd>
					<dt>Direct Inheritance</dt>
					<dd>
						An inheritance of degree one is direct. In other words if the internal prototype of 
						<var>x</var> is <var>y</var> then <var>x</var> directly inherits from <var>y</var>.
					</dd>
				</dl>
			</dd>
			
			<dt>Inherited Property</dt>
			<dd>
				Let <var>x</var> be an object. If <var>x</var> defines a property <var>p</var> directly
				then <var>x</var> does not inherit the property <var>p</var>.
				<p>
					If <var>x</var> does not define <var>p</var> property directly, then look up the inheritance
					chain to find the first member <var>y</var> that defines the property <var>p</var>  directly.
					The fun filled fact is that <var>x.p</var> is defined to be <var>y.p</var> and we say <var>x</var>
					inherits the property <var>p</var> from <var>y</var>. If there is no such member <var>y</var>
					in the inheritance chain of <var>x</var> that directly defines the property <var>p</var>
					then <var>x.p</var> is not defined and <var>x.p === undefined</var> evaluates to true.
				</p>
			</dd>	
			
			<dt>Derivation</dt>
			<dd>
				Derivation is basically synonymous with inheritance. For 
				example if <var>x</var> inherits from
				<var>y</var>, we can say <var>x</var> is derived from <var>y</var>. Furthermore, if <var>x</var>
				inherits a property <var>p</var> from <var>y</var>, then we can say <var>x</var> derives
				the property <var>p</var> from <var>y</var>. Moreover, if <var>x</var> directly inherits
				from <var>y</var>, we can say <var>x</var> directly derives from <var>y</var>. OK! You
				got the idea. 
			</dd>
			
			<dt>Null Object</dt>
 			<dd> 				
 				Any object, which is neither <var>Object.prototype</var> nor inherits 
 				from <var>Object.prototype</var>. 
 				<p>	
			  		You should be able to figure out why an element created from or 
			  		inherited from a null object is a null object.
			  	</p>
 			</dd>
 			<dt>Standard object</dt>
 			<dd>
 				<var>Object.prototype</var> or any object which inherits from it. 				
 				<p style="margin-left:">When most think of an object, it's of a standard object because most don't
 				know about null objects.</p> 				 	
 			</dd> 
 			
 			<dt>Null Class</dt>
 			<dd>
 				A class whose prototype is a null object. It's a fact that class instances of a null class
 				are null objects.
 			</dd>
 			
 			<dt>Object Creation</dt>
 			<dd>
 				The following code shows how to create a new object <var>x</var> from an existing object <var>y</var>.
 				<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
					// Create new object x from existing object y 	
				
					var x = Object.create(y)
					{
						// properties and their property descriptors here
					});
					
					// JavaScript insures that x directly derives from y,
					// and so x inherits the properties of y unless x
					// defines them directly.		
				</div>
 			</dd>
 			
			<dt>Instances</dt>
			<dd>
				<p>
					By definition, an element <var>x</var> is an instance of a class/constructor <var>foo</var>
					precisely when <var>foo.prototype</var> is in the inheritance chain of <var>x</var>, 
					i.e.,
					<var>x</var> derives from <var>foo.prototype</var> directly or indirectly. Actually, this
					definition holds for any function <var>foo</var> being a constructor or not.				
				</p>
				<p>
					A test for instances is that <var>x instanceof foo</var> evaluates to true
					precisely when <var>x</var> is an instance of <var>foo</var>. Except the test
					doesn't work for the <var>BigInt</var>, and <var>Symbol</var> functions. See appendix 
					<a href="#BigIntAndSymbolClasses">Are BigInt and Symbol Classes?</a>					
				</p>
				<p>
					For example <var>"cat" instanceof String</var> evaluates to <var>false</var>,
					which correctly states that <var>"cat"</var> is not an instance of <var>String</var>. In this
					situation JavaScript will not box the string <var>"cat"</var> to a <var>String</var>. 
					As noted before, technically <var>"cat"</var> has no inheritance chain and so can't inherit from 
					<var>String.prototype</var>.
				</p>
				<dl>
					<dt>Class Instances</dt>
					<dd>
						If <var>foo</var> is a class/constructor then an element of the form <var>x = new foo(..)</var>
						is a <dfn>class instance</dfn> of <var>foo</var>.
						<p>
							It's a fact that class instances of <var>foo</var> are instances of <var>foo</var> but the converse
							does not hold because there are instances, for example like <var>Object.create(foo.prototype)</var>,
							which are instances but not class instances.
						</p>
					</dd>
				</dl>
			</dd>		
		</dl>
</section>
<section>
 	<h2>Synonyms for Inheritance</h2>
 	<p>
 		It's strange that there are so many synonyms for the type of derivation and inheritance described above. 
		Multiple committees, not run by cats, were obviously at work. Inheritance/derivation synonyms follow.
 	</p>
	<ol>
		<li>object inheritance/object derivation</li>
		<li>proto inheritance/proto derivation</li>
		<li>prototypical inheritance/prototypical derivation</li>
		<li>prototypal inheritance/prototypal derivation</li>
		<li>prototype inheritance/prototype derivation</li>
	</ol>
	<p>
		The author has seen all five of these used. 
		If you want your listeners to not understand you at all, use prototypal. 
	</p>
 </section>
 <section>
 <h2>Partition of Elements by Inheritance</h2>
 	<table class="web" style="margin-top:2em">
 			<thead style="padding:.5em">
				<tr><th colspan="4" style="background-color:aqua">Partition of Elements by Inheritance</th></tr>
			</thead>
 			<tbody style="padding:.5em">
				<tr>
					<th rowspan="2">
						<span style="font-size:.9em;margin-top:1em;display:block">Elements with no inheritance chain</span>						
					</th>
					<td colspan="3">undefineds</td>
				</tr>
				<tr><td colspan="3">nulls</td></tr>
			</tbody>
			<tbody>
				<tr>
					<th rowspan="7">
					<span style="font-size:.9em;margin-top:1em;display:block">Elements with an inheritance chain</span>
					</th>
					<td colspan="3" style="background-color:#C6FFC6"><dfn>Null Objects</dfn>
					<span style="font-size:.9em;margin-top:1em;display:block">
						is neither <var>Object.prototype</var> nor derives from it</span>
					</td>
					<tr>
						<td rowspan="6" style="background-color:#C6FFC6">
						<span style="font-size:.9em;margin-top:1em;display:block">is or derives from <var>Object.prototype</var></span>
						</td>
						<td rowspan="5"  style="background-color:#FFACAC">Primitives</td>
						<td>boolean</td>
					</tr>
					<tr><td>number</td></tr>
					<tr><td>string</td></tr>
					<tr><td>symbol</td></tr>
					<tr><td>BitInt</td></tr>

					<tr><td colspan="2" style="background-color:#FFACAC">Standard Objects
					</td></tr>
			</tbody>
 		</table>
 </section>
 
 <section>
 	<h2>Testing Inheritance</h2>
 	<p>
 		If <var>x</var> and <var>y</var> are objects, how do you tell if <var>y</var> is in the inheritance 
 		chain of <var>x</var>? All you have to do is ask <var>y</var>. <var>y.isPrototypeOf(x)</var>
 		is <var>true</var> precisely when <var>y</var> is in the inheritance chain of <var>x</var>.
 	</p>
 	<p>
 		On a related note, if <var>x</var> is an object and <var>foo</var> is a constructor then 
 		<var>x instanceof foo</var> is true precisely when <var>foo.prototype</var> is in the
 		inheritance chain of <var>x</var>.
 	</p>
 </section>
 <section>
  <h2>Inheritance Chains of Primitives</h2>
	<p>
		The primitives with an inheritance chain via boxing are <var>boolean</var>, <var>number</var>, 
		and <var>string</var>. The primitives with an inheritance chain are <var>symbol</var> and <var>bigint</var>.
	</p>
	<p>
		The inheritance chain of the number 7 follows.
	</p>
	<ol>
		<li>
			<var>Object.getPrototypeOf(7) = Number.prototype</var>
		</li>
		<li>
			<var>Object.getPrototypeOf(Number.prototype) = Object.prototype</var>
		</li>
	</ol>
	<p>
		Now we are most interested in <var>Number.prototype</var> from which <var>7</var> directly derives.
		We will add a property to <var>Number.prototype</var> and show it is inherited by <var>7</var>.
	</p>
	<div class="codeBox colorLightBurlywood" data-codeNumbers="true">
		<header class="codeHeader colorLightPink">						
			<div class="codeListing"></div>
			Example: numbers are members of the Number class. 
		</header><div class="numberShield colorLightBlue"></div>
				
			// Add a property called <var>message</var> to <var>Number.prototype</var>	
			Object.defineProperty(Number.prototype, 'message',
			{
				value:function()
				{
					alert("Hello! I'm Mr. Number number " + this + "!!");
				}
			});
					
			// And yes the property is immediately available to the number 7						
			(7).message(); // Hello! I'm Mr. Number number 7!! 			
											
	</div>
	<p>
		Analogous discussions hold for <var>booleans/Booleans</var> and <var>strings/Strings</var>.
		See the <a href="#Boxing">Boxing</a> appendix for more information.
	</p>	
</section>
<section>
	<h2>Objects, Standard and Null</h2>
	<section>
		<h3>Test for Objects</h3>
		<p>
			By consensus all elements except for the primitives are objects.
			The primitives are the, <var>undefineds</var>, <var>nulls</var>, <var>booleans</var>, <var>numbers</var>,
			<var>strings</var>, <var>symbols</var>, and <var>bigints</var>. That is the elements <var>x</var> 
			whose <var>typeof(x)</var> is either <var>"undefined"</var>, <var>"null"</var>, <var>"boolean"</var>, <var>"number"</var>,
			<var>"string"</var>, <var>"symbol"</var>, or <var>"bigint"</var>. A defining characteristic of primitives is that
			properties can't be added to them. Its's also true that they do not have any properties of their own.	
		</p>
	
		<blockquote style="margin-top:2em">
			In JavaScript, functions are first-class objects, because they can have properties and methods just like any 
			other object. What distinguishes them from other objects is that functions can be called. In brief, they are 
			Function objects. <br>
			&nbsp;
			<a style="float:right" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions">MDN</a>
		</blockquote>
		
		<table class="web">
		<thead>
			<tr><th colspan="3">Data Types Recognized by the typeof Operator</th></tr>
			<tr><th style="white-space:nowrap">Primitive Data Type</th><td>Categorization</td><td>Test <var>x</var> for Membership</td></tr>
		</thead>
			<tbody>
				<tr><th>null</th><td>The literal <var>null</var> or variable set to such</td><td><var>x === null</var></td></tr>
				<tr><th>undefined</th><td>The literal <var>undefined</var> or variable set to such
					<td><var>typeof(x) == "undefined"</var></td></tr>
				<tr><th>boolean</th><td>The literals <var>true</var>, <var>false</var> or variable set to such</td>
					<td><var>typeof(x) == "boolean"</var></td></tr>
				<tr><th>number</th><td>A literal number or variable set to such<td><var>typeof(x) == "number"</var></td></tr>
				<tr><th>string</th><td>A literal string or variable set to such<td><var>typeof(x) == "string"</var></td></tr>
				<tr><th>BigInt</th><td>A literal BigInt or variable set to such. <br>Or a class instance of BigInt<td><var>typeof(x) == "bigint"</var></td></tr>
				<tr><th>Symbol</th><td>A class instance of Symbol<td><var>typeof(x) == "symbol"</var></td></tr>
			</tbody>
		<thead>			
			<tr><th style="white-space:nowrap">Classless Data Type</th><td>Categorization</td><td>Test <var>x</var> for Membership</td></tr>			
		</thead>
		<tbody>
			<tr><th>function</th><td>A function</td><td><var>typeof(x) == "function"</var></td></tr>
			<tr><th>object</th><td>An object</td><td><var>typeof(x) == "function" || <br> typeof(x) == "object"</var></td></tr>
		</tbody>	
	</table>

		<p>
			From the typeof table we have the following test.
		</p>
		<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
			function isObject(x)
		    {
		        return (x != null&nbsp;&amp;&amp;&nbsp; typeof(x) == 'object') || typeof(x) == 'function';		    
		    }

		</div>
		
		<p>
			No one considers <var>null</var> to be an object but unfortunately <var>typeof(null)</var> 
			evaluates to <var>"object"</var> most likely by a bad original decision.
		</p>
		<p>
			Now <var>x instanceof Object</var> being <var>true</var> is NOT a test for being an 
			object because of the existence of null objects. Also because <var>Object.prototype</var> is an object
			yet <var>Object.prototype instanceof Object</var> evaluates to <var>false</var>.
		</p>
		<p style="margin-left:2em">
			As we shall see <var>x instanceof Object</var> evaluates to <var>true</var> precisely when
			<var>x</var> is a standard object not equal to <var>Object.prototype</var>.
		</p>		
	</section>
	<section>
		<h3>Test for Standard Objects</h3>
		
		<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
			function isStandardObject(x)
		    {
		        return x === Object.prototype || Object.prototype.isPrototypeOf(x);    
		        
				// this says x is either Object.prototype or else derives from it 
		    }
		</div>
	</section>
	<section>
		<h3>Two Tests for Null Objects</h3>		
		<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
			function isNullObject(x)
		    {
		        return x !== Object.prototype &amp;&amp; Object.prototype.isPrototypeOf(x);    
		        
				// this says x is neither Object.prototype nor derives from it 
		    }
		    
		    function isNullObject(x)
		    {
		    	return x.__proto__ === undefined;
		    }
		    
		</div>
		
		<p>	
			Why is the second test definitive? Because by a quirk of JavaScript, a null object starts out 
			with an undefined proto property.  
			If you try to change the proto property it doesn't stick: the proto property
			remains undefined. If you take a standard object and try to set its proto property to 
			undefined it doesn't stick: the proto property remains the same.
		</p>			
		<p class="display">
			General use of the <var>x.__proto__</var> property is deprecated. Use <var>Object.GetPrototypeOf(x)</var> instead.
			JavaScript simply screwed up because <var>x.__proto__</var> is supposed to be the internal prototype of an
			object <var>x</var> but this fails for null objects.
		</p>
	</section>
	<section>
		<h3>Checking for Properties</h3>
		<!-- <p>
			We need to talk about some JavaScript goofiness. Let <var>x</var> be an object. 
			If we set <var>x.a = undefined</var> then we agree that <var>x.a</var> is not defined,
			but it is specified. <var>x.a = b</var> defines the property a as long as <var>b</var>
			is not <var>undefined</var>. If we write <var>x.a = b</var>, then we say <var>x.a</var> is
			specified even if <var>b</var> is <var>undefined</var>. 			
		</p>-->
		<p>
			If you want to know if <var>x</var> or an ancestor defines a property <var>a</var>,
			just check the expression <var>x.a&nbsp;&nbsp;!==&nbsp;&nbsp;undefined</var>. 
			It's true precisely when <var>x</var> or an ancestor has defined the property <var>a</var>. Be 
			careful to use two equality symbols because of JavaScript shenanigans where statements like 
			<var>undefined != null</var> evaluate to false.
		</p>
		<p>
			If you want to know if <var>x</var> specifies the property <var>a</var> directly, check 
			<var>hasOwnProperty(x,a)</var>, which will be true precisely when <var>x</var> 
			directly specifies the property <var>a</var>. 
		</p>
		<div class="codeBox centerTable colorLightPink" 
 			style="border:none;padding:1em;border-radius:20px;font-size:.8em;margin-top:2em">
 			function hasOwnProperty(x,a)
 			{
 				return Object.prototype.hasOwnProperty.call(x, a);			
 			}
	 	</div>	
		<p>
			You may be curious has to why we didn't use <var>return x.hasOwnProperty(a)</var>. Well this works if
			<var>x</var> is a standard object, but not if <var>x</var> is a null object because null objects
			don't inherit <var>hasOwnProperty()</var> from <var>Object.Prototype</var>. 
		</p>	
	</section>
</section>
<section>
  <h2>The Null Objects</h2>
		<p>The only top level null objects take the following form where they are created directly from null.</p>
		<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px;margin-top:2em">
			Object.create(null, 
			{
				// property descriptors here
			});			
		</div>
	<p>
		Any object created directly from <var>null</var> is a top-level null object.
		Any object created directly from a null object is a null object. A class <var>foo</var> is a <dfn>null class</dfn>
		if its prototype <var>foo.prototype</var> is a null object. So a class deriving from a null class is
		a null class. Instances of null classes are null objects. That covers how all null objects
		are created.
	</p>	
	<p>
		Normally the internal prototype <var>Object.getPrototypeOf(x)</var> of an element is its
		<var>x.__proto__</var> property. However, one characterization of <var>null</var> objects
		is that their <var>__proto__</var> property is <var>undefined</var>.
	</p>
	
	<div class="codeBox rounded colorLightPink" style="letter-spacing:1px;" data-codeNumbers="true">
			<header class=" codeHeader colorBurlywood">					
				<div class="codeListing"></div>	
				Constructing Null Objects<br>
				(Derivations of top level null objects through Object.create())
			</header><div class="numberShield colorLightOrange"></div>	
			
			function getTopLevelParent(x)
			{
				if(x === null || x === undefined){return undefined;}
				for(var P = x; Object.getPrototypeOf(P) !== null; P = Object.getPrototypeOf(P));
				return P;				
			}
			
			// Create a top level null object.			
			\^i1var x = Object.create(null, 
			{
				cat:{value:'meouzer'},
				food:{value:'tuna'},
			});\$i1
			
			// Verify x is a null object.
			\^i1alert(getTopLevelPrototypeOf(x) !== Object.prototype);\$i1
			
			// Verify again that x is a null object.
			\^i1alert(x.__proto__ === undefined);\$i1
			
			// Verify that x is a top level object.
			\^i1alert(Object.getPrototypeOf(x) === null);\$i1
			
			// To construct other null objects, continue the 
			// derivation process with Object.create().

			\^i1var y = Object.create(x,
			{
				type:{value:'rambunctious'}
			});\$i1

			// Verify y is a null object
			\^i1alert(y.__proto__ === undefined);\$i1			
			
			// Verify again that y is a null object.
			\^i1alert(getTopLevelPrototypeOf(y) !== Object.prototype);\$i1		
			
			// Verify that y inherits the properties of x with their values.
			\^i1alert(y.cat == "meouzer");
			alert(y.food == "tuna");\$i1			
				
		</div>			
</section>
<section>
  <h2>Class Inheritance</h2>
	<p>
		A class <var>foo</var> has a constructor of the same name. JavaScript always insures that
		an instance <var>x</var> of <var>foo</var> created by a call to <var>foo</var> with operator
		<var>new</var> has internal prototype <var>foo.prototype</var>. 
	</p>
	<p>
		To say that <var>foo</var> derives
		from a class <var>bar</var> is to say the internal prototype of <var>foo.prototype</var> is 
		<var>bar.prototype</var>. To say that <var>foo</var> derives from an object <var>obj</var>
		is to say the internal prototype of <var>foo.prototype</var> is <var>obj</var>.
	</p>
	<p>
	One way to derive the <var>foo</var>
			class from the <var>foo<sub>1</sub></var> class is to use the following code.	However, see
			section <i>Historical Note on Class Inheritance</i>. 		
  </p>
		<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
			foo.prototype = Object.create(foo<sub>1</sub>.prototype,
			{
				// property descriptors here
			});		
			
			// Since foo.protoype is created from foo<sub>1</sub>.prototype, the 
			//	internal prototype of foo.prototype must be foo<sub>1</sub>.prototype
		</div>
		<p>
			Now let's say <var>foo</var> derives from <var>foo<sub>1</sub></var>, <var>foo<sub>1</sub></var> derives
			from <var>foo<sub>2</sub></var>, and the derivations continue until <var>foo<sub>last</sub></var>
			which is not created from any other class or element. Then an instance <var>x</var> of 
			<var>foo</var> has the following inheritance chain.
		</p>
		
		<img alt="" src="PrototypeChain.svg" style="margin-top:2em;margin-bottom:2em">
		<p>This means the instance of <var>x</var> of <var>foo</var> inherits all the properties of the <var>foo</var> prototypes 
		and <var>Object.prototype</var>.</p>
		
		<p>
			Now, if <var>foo<sub>last</sub></var> were created directly from <var>null</var> as in 		
		</p>
		<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
			foo<sub>last</sub>  = Object.create(null,
			{
				// property descriptors here
			});
		</div>
		<p>then he inheritance chain of <var>x</var> is the following (excluding null) </p>		
		<img alt="" src="PrototypeChain2.svg" style="margin-top:2em;margin-bottom:2em">
		<p>
			This means the instance of <var>foo</var> inherits the properties of all the foo prototypes but
			doesn't inherit from <var>Object.prototype</var>. <var>foo<sub>last</sub>.prototype</var>
			is a top level null object. You may want this if you desire to 
			eliminate the inheritance
			baggage from <var>Object.prototype</var>. 			
		</p>
		<p>
			Since <var>Object.prototype</var> doesn't sit atop the inheritance chain, then by our definition of null
			object, the whole chain from <var>x</var> to <var>foo<sub>last</sub>.prototype</var>
			are in fact null objects. 
		</p>
		<p>
			We say that <var>foo</var> to <var>foo<sub>last</sub></var>
			are <dfn>null classes</dfn>, which is appropriate because their prototypes are null objects, 
			and all their instances are null objects.
		</p>		
		<p> 
			In the first type of derivation, the prototypes of constructors are always given a constructor
			property set up by JavaScript itself. However, for null classes JavaScript 
			fails to do its duty and there is never a constructor to be found.
		</p>
		<section>
			<h3>Review</h3>
			<img alt="" src="ClassInheritance.svg" style="margin-top:2em;margin-bottom:2em">
			<p>
				Recall that by definition, class inheritance of <var>foo</var> from <var>bar</var> 
				means object inheritance of <var>foo.protoype</var> 
				from <var>bar.prototype</var>.
			</p>
			<p>
				If you follow the arrows around you can see that <var>x</var>, an 
				instance of <var>foo</var>, inherits from 
				<var>foo.prototype</var>, from <var>bar.prototype</var>, and from <var>foobar.prototype</var>.
			</p>
			<p>
				It's common and very incorrect to hear that JavaScipt is classless. Constructors/classes are first class
				JavaScript citizens whose job is to build objects, and bind private variables and public methods. 
				A <i>class</i>, is identified with a constructor and refers to 
				all objects (class instances) created by the constructor. 	
				Since class inheritance of <var>foo</var> from <var>bar</var> is defined as object inheritance 
				of <var>foo.protoype</var> from <var>bar.prototype</var>, a great leap is taken and you will hear from 
				various author's that JavaScript is a classless language, but again this is incorrect.				 
			</p>			
		</section>			
</section>
<section>
	<h2>Appendices</h2>
	<section>
		<h3>The <i>Writable</i> Property Descriptor is "Inherited"</h3>
		<p>
			We assume the reader knows all about property descriptors, perhaps from MDN (Mozilla Developer Network). 
			The object <var>P = Object.getOwnPropertyDescriptor(x, "prop")</var> is the property
			descriptor of the property <var>prop</var> for the object <var>x</var>. The property descriptor
			has a <var>writable</var> property, which is <var>true</var> precisely when the corresponding 
			property of <var>x</var> may be assigned a (new) value through an assignment statement as in 
			<var>x.prop = 7</var>.			
		</p>
		<p>
			If <var>x.prop</var> is defined with a property descriptor, the default value for <var>writable</var>
			is <var>false</var>, and if <var>writable</var> is <var>false</var> then statements like 
			<var>x.prop = 7</var> have no effect.
			Now you may be suprised by the fact that if <var>y</var> derives from <var>x</var> then statements
			like <var>y.prop = 7</var> also have no effect: In other words the writability of the property 
			was inherited from <var>x</var> to <var>y</var>. More simply, you could say the writability of the property
			of <var>y</var> was derived from <var>x</var>.				
		</p>
		<div class="codeBox rounded colorLightPink" style="letter-spacing:1px;" data-codeNumbers="true">
			<header class=" codeHeader colorBurlywood">					
				<div class="codeListing"></div>	
				Inheriting <i>Writable</i>
			</header><div class="numberShield colorLightOrange"></div>	
			
			const x = Object.create(Object.prototype,
			{				
				cat:
				{
					value:"Meouzer"
					// The writable property of cat is not specified
					// and is therefore false by default.
				}
			});		
		
			const y= Object.create(x,
			{
				//cat: 
				//{								
				//	value:"Pete"
				//}
			});
						
			y.cat = "Pete";  // No effect. As if non writable were inherited.
			alert(y.cat);      // Meouzer
	    	
	    	// You can still redefine y.cat, but just not through assignment.
	    	// Uncomment the lines just after line 4, comment out line 5,
	    	// and you get the expected redefinition: Line 6 will alert "Pete." 
	    		    	
		</div>
		
		<p>
			Since you know all about property descriptors, the above example with comments shows that the
			configurable property descriptor is not inherited.
		</p>
		
	</section>
	
	
	<section>
		<h3>Casting</h3>
		<p>
			The statement <var>Object.setPrototypeOf(x, y)</var> resets the internal prototype of <var>x</var> to <var>y</var>.
			The author calls this a <dfn>cast</dfn> of <var>x</var> to <var>y</var>.  The cast changes the object from which <var>x</var>
			directly inherits and so changes the entire inheritance chain of <var>x</var>. However, the cast will result in a
			<dfn>broken object</dfn> if <var>x</var> doesn't support the methods in its new inheritance chain.
		</p>
		<p>
				Let's suppose that an  object <var>x</var> inherits from an object  <var>y</var>.					
	  	</p>
		<ol>
				<li>The statement <var>Object.setPrototypeOf(x, y)</var> is an <dfn>upward cast</dfn> of <var>x</var> to
				<var>y</var>. </li>
				<li>The equation <var>Object.setPrototypeOf(y, x)</var> is a 
				<dfn>downward cast</dfn> of <var>y</var> to <var>x</var>.	</li>
				<li>
					If neither <var>x</var> nor <var>z</var> lie in the inheritance chain of the other then the statement
					<var>Object.setPrototypeOf(x,z) </var> is a <dfn>sidewise cast</dfn> of <var>x</var> to <var>z</var>.
 				</li>
		</ol>
		<p>
				An upward cast is the most likely to succeed by not resulting in a broken object. A downward cast is the next
				most likely to succeed, and a sidewise cast is the least likely to 
				succeed.
		</p>	
		<p>
			If you ever decide to cast, be careful and test. The author has seen a cast object whose inherited
			properties run 20 to over 100 times slower than normal.
		</p>
		<p class="display">
			In any particular sitiuation this may or may not make sense. However, you can cast standard objects
			to null objects, you can cast null objects to standard objects.  
		</p>		
							
  </section>
	<section id="Boxing">
  		<h3>Boxing</h3>
	  	<p>
	  		The primitive types with an "inheritance" chain via boxing are <var>boolean</var>, <var>number</var>, <var>string</var>,
	  		while <var>binints</var> and<var>symbols</var> have actual inheritance chains.
	  		
	  	</p>
	  	<img alt="Primitive-Chains.svg" src="Primitive-Chains.svg" style="width:400px;padding:2em 0" class="centerTable">
  	
	  	<div class="codeBox centerTable colorLightPink" style="border:none;padding:1em;border-radius:20px">
			Object.defineProperty(Boolean.prototype, "getMyTypeOf",
			{
				value:function()
				{
					return&nbsp;typeof(this);
				}
			});
			
			var b = true;
			alert(typeof(b)); 			         // "boolean"
			alert(b.getMyTypeOf());  	// "object"
			
		</div>
		<p>
			What this code says is that when you apply an inherited property to a <var>boolean</var>, the <var>boolean</var> is 
			first
			boxed behind the scenes to obtain a <var>Boolean</var> and then the property is applied to that <var>Boolean</var>, 
			which is why we get <var>"object"</var> and not <var>"boolean"</var> as the result of <var>getMyTypeOf()</var>.
		</p>
		
		<p>
			For another boxing example, see the next section.
		</p>
  	</section>
  	  
	<section>
		<h3>A Note on Class Prototypes</h3>
		<p>
			Let's look at an example where we create a property for <var>Klass.prototype</var>. We of course
			want to use this property on class instances of <var>Klass</var>. We want use the property
			on  <var>Klass.prototype</var> itself (though 99.9999% of the time you don't) and we want
			to use the property of instances of <var>Klass</var> that are not class instances of <var>class</var>
			(though 99.9999% of the time you don't want to do this either).		
		</p>
		<p>
			Let's say you want to prototype copy functions for all the built in classes, and objects in general.				   
		</p>
		
		<div class="codeBox rounded colorLightPink" style="letter-spacing:1px;" data-codeNumbers="true">
			<header class=" codeHeader colorBurlywood">					
				<div class="codeListing"></div>	
				A copy function for class instances of Boolean 
			</header><div class="numberShield colorLightOrange"></div>	
			
			Object.defineProperty(Boolean.prototype, 'copy',
			{			
				value:function()         
				{	
					if(typeof(this) == "boolean") return this; 				                // Failed attempt to avoid boxing
					if(isBoolean(this)) return new Boolean(this.valueOf()); // for class instance of Boolean
					if(this === Boolean.prototype) return this; 			               // for the prototype
					return Object.create(Object.getPrototypeOf(this)); 		   // for other instances of Boolean
				}
			});
			
			// First the attempt to avoid boxing is impossible. As soon as true.copy() is called
			// true is boxed as new Boolean(true), and so line 3 does not get executed. Line 4
			// gets executed instead. If x = new Boolean(true), then the call x.copy()
			// executes line 4 and a copy is made. For the prototype something that 
			// makes sense is returned on line 5. For the other instances of Boolean something
			// that makes sense is returned on line 6, but in general there may be nothing to 
			// write that makes sense.  
			
			// In general, class prototype properties could be written as follows. The theme is
			// that if an object can't use a property, the property should be set to undefined for
			// that object.
			
			Object.defineProperty(Boolean.prototype, 'property',
			{			
				value:function()         
				{									               
					if(isBoolean(this)) return "something";       // for class instance of Boolean
					return undefined;   				// For Boolean.Prototype and remaining instances of Boolean  
				}
			});
			
			// or 
			
			Object.defineProperty(foo.prototype, 'property',
			{			
				value:function()         
				{									               
					if (Object.getPrototypeOf(this) === foo.prototype)
					{ 
						return "something"; // for class instances of foo
					}       
					return undefined;   				// For foo.Prototype and remaining instances of foo  
				}
			});
		

		</div>		
	</section> 
	<section>
		<h3>Historical Note on Class Inheritance</h3>
		<p>
			Everyone now knows that to derive a class <var>foo</var> from <var>bar</var> one can 
			create <var>foo.prototype</var> with <var>Object.create()</var> with first parameter
			<var>bar.prototype</var>. As in		
		</p>
		<div class="codeBox centerTable" style="border:0">
		
			foo.prototype = Object.create(bar.prototype, 
			{
				// Property Descriptors for foo.prototype here.
			});
				
		</div>
		<p>
			However, there was a time when there was no <var>Object.create()</var> and no <var>__proto__</var>
			exposed for manipulation. So what did programmers do? It seems a lot of smart programmers did
			a silly thing because JavaScript did not expose a good way of deriving. The 
			capability of useful
			derivation was always there, but JavaScript did not make it available. The correct way was very
			obscure.		
		</p>
		<p>
			Douglass Crockford wrote about this obscure technique at	
			<a href="http://crockford.com/javascript/prototypal.html" target="_blank">
				http://crockford.com/javascript/prototypal.html</a>,
			but I don't think anyone caught on. I found this technique on my own, which is why I
			recognized it while reading Crockford. 
			My version is <var>protoProxy</var>.
		</p>
		<div class="codeBox colorLightBurlywood" style="display:table-cell" data-codeNumbers="true">
			<div class="numberShield colorLightBlue"></div>
			
			protoProxy = function(myClass)
		    {
		        function foobar(){};
		        foobar.prototype = myClass.prototype;
		        return new foobar();
		    } 
		    
		    // Now to derive the class foo from bar, write one short line.
		    foo.prototype = protoProxy(bar);
		    
		</div>
		
		<p>
			So <var>protoProxy</var> was the historical substitute for <var>Object.create()</var> and completely
			equivalent to it. Now what was the silly thing that programmers did, me included? Instead of line 5, 
			one would write the following. 
		</p>
		<div class="codeBox centerTable" style="border:0">
			foo.prototype = new bar(...);
		</div>
		<p>
			Nowadays, you don't have to think hard on why this is bad, unless you really want to derive
			from an instance, but everyone did it way back.
		</p>
		<p>
			What protoProxy does is to insure that the internal prototype of <var>foo.prototype</var>
			is <var>bar.prototype</var>, which means that <var>foo</var> derives from <var>bar</var>.
			This is just protopalriffic. 	
		</p>	
	</section>
	<section>
 		<h3>Top of the Inheritance Chain</h3> 		
 		<div class="codeBox centerTable colorLightPink" 
 			style="border:none;padding:1em;border-radius:20px;font-size:.8em;margin-top:2em">
 			function getLastPrototypeOf(x)
			{
				if(x === null || x === undefined){return undefined;}
				for(var P = x; Object.getPrototypeOf(P) !== null; P = Object.getPrototypeOf(P));
				return P;				
			}
 		</div>	
 		<p>
 			<var>getLastPrototypeOf(x)</var> is the top-level element from which <var>x</var> inherits.
 		</p>
 		<p>
 			The most distinguished top-level element is <var>Object.prototype</var>. There are infinitely many
 			possible top level null objects every one of which is created from <var>null</var> as follows.
 		</p>
 		<div class="codeBox centerTable colorLightPink" 
 			style="border:none;padding:1em;border-radius:20px;font-size:.8em;margin-top:2em">
 			
 			var myTopLevelNullObject = Object.create(null, {
 				//property descriptors here
 			});
 		</div>
 	</section> 
 	<section>
 		<h3 id="BigIntAndSymbolClasses">Are BigInt and Symbol Classes?</h3>
 		<p>
 			<var>BigInt</var> is a function that, creates an element, enforces a contract on it, and 
 			sets its prototype to <var>BigInt.prototype</var>. But that's exactly the job of a constructor and 
 			so <var>BigInt</var> perfectly mimics a constructor even though <var>new</var> isn't used. 
 			The same discussion holds for <var>Symbol</var>.
 		</p>
 		
 		<p>
 			Let <var>x = BigInt(7)</var>. It's a fact that the internal prototype of <var>x</var>,
 			<var>Object.getPrototypeOf(x)</var>, is <var>BigInt.prototype</var>. 			
 		</p> 		
 		<p>
 			The case against being classes is that both <var>x instanceof BigInt</var>
			and <var>BigInt.prototype.isPrototypeOf(x)</var> evaluate to <var>false</var>.
			However, these two are obvious JavaScript screw ups because both say that
			<var>x</var> can't inherit from <var>BigInt.prototype</var>, but this 
			contradicts the fact that it does inherit from <var>BigInt.prototype</var> 
			because the internal prototype of <var>x</var> is <var>BigInt.prototype</var>. 			
 		</p>
 		<p>
 			The author suspects that behind the scenes, a <var>bigint</var> is a object masquerading as
 			a primitive. This is because <var>x.__proto__ = BigInt.prototype</var>. So a <var>bigint</var>
 			has a <var>proto</var> property and is hence an object by our definition of object. You 
 			might say <var>x.__proto__ === BigInt.prototype</var>  is <var>true</var> only by boxing, but what
 			would <var>x</var> be boxed to? There is no answer! Maybe our definition of object
 			should be changed.
 		</p>
 		<!-- 
 		<p>
 				For every other function <var>foo</var>, the first step in creating instances of <var>foo</var>
 				is to either first take a class instance of <var>foo</var>, or to use <var>Object.create()</var>
 				on <var>foo.prototype</var>. Since <var>Object.create()</var> is 
				obviously not being used, we
 				infer that it is very logical that <var>x</var> is a class instance and therefore <var>BigInt</var> is a
 				class/constructor. 
 		</p> -->		
 	</section>	
</section>

<section>
	<h2>From the Meouzer Collection</h2>
	<p class="centerTable colorLightPink" style="border-radius:20px;padding:2em;font-size:1.1em">
		Well I hate to confess<br>
		but doing JavaScript is a stress<br>
		so Meouzer got to working<br>
		and after he quit smirking<br>
		turned my JavaScript into a real mess		
	</p>

</section>




<br><br><br><br><br><br><br><br><br>
	
</body>

</html>


